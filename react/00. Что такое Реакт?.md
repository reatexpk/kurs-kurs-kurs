# Что такое Реакт?
Реакт выбирают уже 10 лет, почему это вряд ли когда-то закончится?

## История фронтэнда

В курсе по вёрстке мы разбирали самую обычную вёрстку через ХТМЛ и ЦСС. Да, стандарты развиваются, W3C и WHATWG делают правильные вещи, но на вёрстке интерфейсы не построишь.

### jQuery — 2006, Google Chrome — 2008

Примерно в 2006 году [появилась](https://en.wikipedia.org/wiki/JQuery) библиотека Джквери — мощная штука, цель которой была унифицировать поведение браузеров. На тот момент было не так много браузеров и у всех них была разная реализация одного и того же! Джквери это исправлял: прятал реализацию за небольшими функциями. Эти функции — АПИ библиотеки, про АПИ мы ещё поговорим.

Затем в 2008 году Гугл вышел на рынок браузеров со своим Хромом и движком V8: это был прорыв, браузеры, оказывается, могут быстро работать! После ИЕ6 и всяких Опер это был глоток воздуха, поэтому Хром очень быстро стал браузером №1. That shit cray!

### Backbone.js и Knockout — 2010

Прошло два года, браузеры развиваются (Майкрософт сподобился выпустить ИЕ8 в 2009, но он давно уже был не жилец), железо улучшается, а DX (Developer Experience) не особо.

Посудите сами: у нас появилась возможность делать какие-то приложения, началось обсуждение [Флекбоксов](https://en.wikipedia.org/wiki/CSS_flex-box_layout), через год появится [Бутстрап](<https://en.wikipedia.org/wiki/Bootstrap_(front-end_framework)>), а мы до сих пор через Джквери пишем огромную лапшу кода чтобы работать с интерфейсом. Не очень удобно.

В те времена был популярен Ruby On Rails с подходом Model-View-Controller (он считался самым удобным), поэтому какой логичный результат? Давайте заберём его на фронтэнд и сделаем Backbone.js! Заодно и Knockout, но уже на MVVM (Model-View-ViewModel).

MVC это способ работы с данными: есть **модель** данных, есть **контроллер**, который ею управляет, есть **вью**, который их отображает.

MVVM ещё хуже, вот что вам про него нужно знать! Но если серьёзно, то это лежит в области two-way data binding: работа с данными в обе стороны (через вью обновляется модель, через модель обновляется вью).

### AngularJS — 2010 и EmberJS — 2011

В том же 2010 вышел Ангулар — фреймворк от Гугла, в котором и был реализован MVVM. Отличие фреймворков от библиотек в том, что они диктуют вам правила и предоставляют много готовых решений: представьте как удобно получить несколько библиотек от одного поставщика!

Спойлер: неудобно. Потому что эти решения рассчитаны на типовые решения, если ваше в него не укладывается — здравствуйте, костыли и велосипеды.

Ангулар был неплохим: после Джквери (Нокаут и Бэкбон не особо завоевали популярность) это был глоток свежего воздуха. Проблем у Ангулара было несколько:

* это всё ещё MVC/MVVM,
* стандарты не были готовы к two-way data binding и в итоге он был очень прожорлив по ресурсам,
* разработчики Ангулара тоже не особо умели это исправить,
* Ангулар2 должен был быть совершенно другим — потеря обратной совместимости.

Тем не менее, с Ангуларом мы прожили несколько лет пока в марте 2013 года не появился Реакт. Примерно в те же времена был анонс Ангулара 2 без обратной совместимости, поэтому Реакт был весьма кстати!

### Реакт — 2013

Реакт был удивительным: он принёс с собой компонентный подход, локальный стейт и декларативный подход, где интерфейс рендерится (показывается) от данных. Уравнением это выглядит как `ui = render(state)`, чуть позже вы это поймёте.

Итак, представьте: у вас есть данные, например, вы работаете с недвижимостью и у вас есть список объектов, который нужно отрисовать. В MVC вам бы пришлось размазывать это на три слоя (и вообще помнить что они существуют! представьте как это неудобно), а тут всё в одном компоненте.

Я вам покажу псевдокод, думаю, вы его поймёте:

```jsx
class PropertiesList extends React.Component {
  state = {
    properties: [
      {
        id: 101,
        title: "2-комнатная квартира в Хамовниках",
        images: [
          {
            id: "PRO-101-6c0mq7u3Qo",
            isPublic: true
          },
          {
            id: "PRO-101-7EScTXC6zT",
            isPublic: false
          }
        ]
      },
      {
        id: 201,
        title: "5-комнатный пентхаус в Тверском",
        images: [
          {
            id: "PRO-201-oazwaN0JTS",
            isPublic: true
          },
          {
            id: "PRO-201-zptmLoC38q",
            isPublic: false
          }
        ]
      }
    ]
  };

  render() {
    return (
      <section>
        <h2>Список квартир</h2>
        {this.state.properties.map(property => (
          <a href={`/properties/${property.id}`} key={property.id}>
            <img src={`https://images.com/${property.images[0].id}`} />
            <h3>{property.title}</h3>
          </a>
        ))}
      </section>
    );
  }
}
```

Не то чтобы сложный, но не то чтобы очень понятный. Это ок — это же курс, всё предстоит впереди :)

Тем не менее, уже видно что стейт и рендер находятся в одном классе. В одном компоненте.

---

Кстати, одно из важных отличий Реакта от всего остального типа Ангулара или Эмбера: он работает с Джаваскриптом, а не с придуманным шаблонизации.

Если вы [посмотрите на Вью](https://vuejs.org/v2/guide/), то мало того что там MVVM, так ещё и свой птичий язык:

```html
<div id="app-2">
  <span v-bind:title="message">
    Hover your mouse over me for a few seconds
    to see my dynamically bound title!
  </span>
</div>

<div id="app-3">
  <span v-if="seen">Now you see me</span>
</div>

<div id="app-4">
  <ol>
    <li v-for="todo in todos">
      {{ todo.text }}
    </li>
  </ol>
</div>
```

Все эти `v-bind`, `v-if`, `v-for` — это не из нативного ХТМЛа или Джаваскрипта. У Реакта всё построено на чистом Джаваскрипте и в этом его гигантский плюс.

---

## Реакт – 2019
Реакт тем временем не стоял на месте и, как и многое во фронтенде, эволюционировал. В 2019 году была выпущена версия Реакта 16.8, одной из главных фич которого стали хуки. В какой-то момент разработчики реакта подумали и решили, что громоздкие классы пора бы заменить привычными функциями. И если раньше выбор между тем, какой компонент тебе делать – классовый или функциональный – определялся по принципу: нужен локальный стейт или методы жизненного цикла компонента – делаем класс, если нет – делаем функцию, то теперь все компоненты можно записать простой функцией.

Например, вот код, о котором было упомянуто выше, но уже на хуках:
```jsx
const PropertiesList = () => {
  const [properties, setProperties] = React.useState([
    {
      id: 101,
      title: '2-комнатная квартира в Хамовниках',
      images: [
        {
          id: 'PRO-101-6c0mq7u3Qo',
          isPublic: true,
        },
        {
          id: 'PRO-101-7EScTXC6zT',
          isPublic: false,
        },
      ],
    },
    {
      id: 201,
      title: '5-комнатный пентхаус в Тверском',
      images: [
        {
          id: 'PRO-201-oazwaN0JTS',
          isPublic: true,
        },
        {
          id: 'PRO-201-zptmLoC38q',
          isPublic: false,
        },
      ],
    },
  ]);

  return (
    <section>
      <h2>Список квартир</h2>
      {properties.map((property) => (
        <a href={`/properties/${property.id}`} key={property.id}>
          <img src={`https://images.com/${property.images[0].id}`} />
          <h3>{property.title}</h3>
        </a>
      ))}
    </section>
  );
};

```

Примеры довольно похожи, стало меньше кода, исчезли классы и все связанное с ним. Но, тем не менее, это был революционный в то время подход и предлагал принципиально новый подход работы с компонентами и логикой. После этого обновления все разработчики резко кинулись переписывать свои проекты с использованием хуков. Сейчас уже редко можно встретить код на классах, хотя и он все еще существует.

С тех пор Реакт получил еще несколько мажорных обновлений, добавились новые хуки, некоторые были переделаны, а также появилось огромное количество кастомных хуков для огромного количества действий. Например, репозиторий [react-use](https://github.com/streamich/react-use) содержит десятки разных хуков на каждый случай жизни.

## Плюсы Реакта и его перспективы

* **Декларативен**, а потому предсказуем: каждый раз вы будете получать один и тот же результат,
* **Быстр**: он использует virtual dom и обновляет только измененный кусок,
* **Жив**: коммьюнити Реакта — самое гигантское и оно не думает его забрасывать,
* **Используется Фейсбуком**: eat your own dog food, как говорится,
* **Чертовски популярен**: Реакт на первом месте в выборе работодателей и разработчиков. Несмотря на то, что и ему уже на пятки наступают Svelte и Solid (пример: [The State Of JavaScript 2022](https://2022.stateofjs.com/en-US/libraries/front-end-frameworks)), он до сих пор считается самым популярным в мире.
* **Подходит для всех проектов**: от маленьких за день до крупных внутренних систем.

Это не сейл-спич. Реакт действительно поменял фронтэнд и он идеален настолько, насколько это возможно. Реакт стал стандартом во фронтэнде.

### Принципы Реакта

iframe: https://www.youtube.com/embed/f11f8ksArp4

_Монтаж дерьмовый: звук с камеры (а не с микрофона), торчит "2 неделя", в будущем исправим_

## Итог

Сегодня мы очень коротко коснулись Реакта: узнали что он компонентный и предлагает использовать чистый Джаваскрипт в отличие от Вью, Ангулара или каких-либо ещё фреймворков и библиотек.

Зато мы узнали про историю фронтэнда!

