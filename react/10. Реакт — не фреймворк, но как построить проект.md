# Реакт — не фреймворк, но как построить проект?

Архитектура и основные модули из экосистемы Реакта

Чем в сознании разработчика библиотека отличается от фреймворка? Библиотека решает конкретную задачу, фреймворк даёт экосистему и диктует архитектуру.

Когда впервые знакомишься с Реактом, то после всяких Ангуларов не понимаешь, как же с ним работать: это же библиотека для вёрстки, почему я должен её использовать? У меня всё хорошо, есть `@angular/common/http`, `@angular/universal`, `@angular/router` и прочее, а тут мне нужно из говна и палок слепить проект, не хочу этим заниматься!

Так-то оно правда, но вы пользуетесь Реактом в 2024 году, а не в 2014, когда ещё ничего не было, так что сегодня мы рассмотрим основные библиотеки, которые можно использовать с Реактом.

## Библиотеки

### Стилизация

Как вы понимаете, [Styled Components](https://styled-components.com). Эту идеальную библиотеку пока никто не переплюнет.

Некоторые любят CSS модули, которые работают с файлами `*.module.css` или `*.module.scss` на уровне бандлера и инжектят стили в код.

### Роутинг

Его мы тоже проходили, это [Реакт-роутер](https://reactrouter.com/en/main).

### ХТТП-запросы

Тут два варианта: либо голый [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) в `useEffect`'ах, либо рекомендуемые командой реакта штуки по типу [TanStack Query](https://tanstack.com/query/latest).

При использовании TanStack Query можно все так же использовать `fetch`.

Скорее всего, сейчас TanStack Query будет стандартом в реакте и стоит использовать именно его. И вообще реакт все больше обрастает полноценными фреймворками, у которых уже это все есть из коробки.

### Формы

В интерфейсах часто бывают формы: инпуты, селекты и прочие поля ввода, а у форм ведь должна быть валидация данных и прочие возможности.

[react-hook-form](https://react-hook-form.com/) — самый хороший вариант для этого.

### Хранение данных

Тема очень холиварная: кто-то говорит используйте локальный стейт компонента или его родителей, кто-то предпочитает стейт менеджеры типа Редакса или Мобикса.

Команда реакта выступает за использование стейта компонентов.

Почему часто советуют Редакс или Мобкс? Потому что в 2015 Редакс был очень модным и все старались его воткнуть себе в проект, а потом оказалось, что он на пустом месте усложняет проект. Сам Дэн Абрамов говорит, что скорее всего [вам не нужен Редакс](https://medium.com/@dan_abramov/be46360cf367).

Но я бы не сбрасывал их со счетов, так как это все равно очень хорошие инструменты. Кроме того, тот старый всратый Редакс уже не всратый, так как появился [Redux Toolkit](https://redux-toolkit.js.org/) — переосмысленный редакс. 

Есть ещё относительно новая штука, которая называется [`Effector`](https://effector.dev/). Выглядит очень достойно, на мой взгляд. Возможно, лично я бы в новый проект взял именно его, поскольку мне нравится [концепция отделения бизнес-логики от отображения](https://kelin2code-mu.vercel.app/posts/stop-writing-logic-in-components). Но он гораздо менее популярный, чем все остальное.

Короче говоря, стоит попробовать все и решить, что нравится больше лично вам.

### Бутстрап или его замена

Сейас полно UI китов на любой вкус. Вот некоторые из них:
* [Ant Design](https://ant.design/)
* [Material UI](https://mui.com/)
* [Chakra UI](https://v2.chakra-ui.com/)
* [Mantine](https://mantine.dev/)
* [React Bootstrap](https://react-bootstrap.netlify.app/)
* или можно собрать свой на [Tailwind](https://tailwindcss.com/)
* и ещё куча других

Обычно в крупных команиях свой UI кит, например, у ВК есть [VK UI](https://vkcom.github.io/VKUI/#/About), в Контуре есть [React UI](https://tech.skbkontur.ru/react-ui/), в Альфа Банке есть [core-components](https://alfa-laboratory.github.io/core-components/master/?path=/story/%D0%B3%D0%B0%D0%B9%D0%B4%D0%BB%D0%B0%D0%B9%D0%BD%D1%8B-%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D0%BE-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%8B--page) и так далее

### Даты

[date-fns](http://date-fns.org) либо [day.js](https://day.js.org/)

[moment.js](https://momentjs.com/) слишком жирный и придерживается мутабельности — это неудобно. Кроме того, он депрекейтед.

### Селекты и автодополнения

Обычно они уже есть в UI ките, но если нужно отдельно, то [react-select](https://react-select.com/home) неплохой вариант.

Сейчас есть [downshift](https://github.com/paypal/downshift), но это достаточно низкоуровневая библиотека, поверх которой можно строить свои компоненты — посмотрите [примеры](https://github.com/paypal/downshift#examples) в документации.

### Карты

Зависит от сервиса, который вы используете: например, [`google-map-react`](https://github.com/istarkov/google-map-react) или [`react-yandex-maps`](https://www.npmjs.com/package/react-yandex-maps).

### Графики

Обычно все графики работают поверх [d3.js](https://d3js.org/) — это самая мощная библиотека для работы с ними, посмотрите на [эти демки](https://bl.ocks.org/), которые собирает автор.

[vx](https://vx-demo.now.sh) — библиотека, которая дружит d3 и Реакт.

---

Обычно хватает поиска в Гугле «react x», а после остаётся только выбрать.

Вот несколько правил:

* **версия желательно не должна быть 0.х**: по Семверу всё [может](http://semver.org/) сломаться,
* **понятные описания релизов**: если нет файла `CHANGELOG.md` или вкладка Releases на Гитхабе пустует, то вам сложно будет обновляться,
* **должны быть ишью и пулл-реквесты**: библиотекой должен пользоваться кто-то кроме её автора.
* **их не должно быть слишком много**: если их несколько тысяч и висят они по несколько лет, то ваша вероятность столкнуться с нерешаемой проблемой стремится к 100%
* **желательно, чтобы была изначально написана на тайпскрипте**: так будет меньше багов + родные типы от мейнтейнеров библиотеки, а не от сторонних разрабов

## Архитектура проекта

Едем дальше. Частый вопрос: а как организовывать проект?

### Бизнес-логика превыше всего

Организация проекта строится по **бизнес-логике**: нет нужды делать кучу директорий `src/components/Properties`, `src/containers/Properties`, `src/actions/Properties`, `src/api/Properties`, если можно всё положить в `src/Properties/{actions,api}`.

Объединять по доменам проще, чем бегать по 10 директориям, вы же в один момент времени работаете только с одной сущностью?

Например, вам нужно сделать авторизацию, `Auth`: две страницы (логин, регистрация), несколько компонентов, запросы к серверу. Когда вы её делаете, вы же не отвлекаетесь на другие компоненты или файлы? Вы работаете конкретно над авторизацией.

Думайте продуктом, а не ненужными абстракциями типа компонентов или контейнеров. Люди в вашем продукте пользуются конкретной функциональностью, а не экшенами, редьюсерами или контейнерами.

### Избавьтесь от components

Нет, я серьёзно: даже после предыдущего пункта люди часто оставляют директорию `components`. У вас всё приложение построено на компонентах, зачем директорию отдельно создавать?

Если хотите какой-нибудь хедер или футер переиспользовать на разных страницах, то положите в корень `src`, а не в `src/components` или `src/shared`.

Для интерфейсных вещей типа форм, кнопок и прочего обычно используют `src/ui`.

### Не создавайте директории ради одного файла

Часто вижу `src/Header`, в котором лежит сиротливый `index.ts`. Зачем? На будущее? Преждевременные оптимизации — корень всех бед.

Положите в `src/Header.ts`.

### Переиспользуйте компоненты

Ещё один частый вопрос: а как мелко дробить компоненты?

Дробите до переиспользуемости. Если у вас есть два огромных блока, в которых повторяется только кнопка, то вынесите кнопку в отдельный компонент, а всё остальное оставьте как есть: смысл дробить меньше?

Но если работать неудобно с компонентом — то дробите тоже.

### Feature Sliced Design (FSD)

Если собрать все вышесказанное про архитектуру, то есть хороший вариант, который эти проблемы устраняет. Это методология [FSD](https://feature-sliced.design/). Ее суть делить все приложение на слои: `shared`, `entites`, `features`, `pages`, а слои на сегменты: `ui`, `model`, `api`, `lib`.

ФСД довольно часто стал использоваться в последнее время. Из минусов: не очень понятная документация, которая вызывает кучу вопросов, куда положить какой-нибудь компонент. Но если приноровиться, то выходит плюс минус удобно.

## Итог

Сегодняшним уроком я хотел вам показать, что Реакт это устоявшаяся экосистема, где либо используются стандарты (фетч), либо есть давно устоявшиеся библиотеки, заточенные чисто под Реакт.
