# Vite как спасение наших душ
Как начать писать код уже сейчас, а не тратить 10 тысяч лет на настройку Вебпака

В прошлом уроке мы попробовали написать совсем крошечное приложение из трёх компонентов, но уже поняли, что с `createElement` это чертовски сложно — читаемость кода почти нулевая, конечно.

Тем не менее давайте освежим память прежде чем пойдём в инструменты, которые скроют от нас детали реализаций:

* Реакт — это чистый Джаваскрипт и работает на функции `React.createElement`;
* `React` это не рендерер, а библиотека для построения дерева элементов и его обновления, за это отвечает ВиртуалДОМ;
* За рендер в браузер отвечает библиотека `react-dom`, но бывают ещё `react-pdf`, `react-native` и другие;
* Реакт это компонентный подход, в котором для передачи данных используют пропы — атрибуты с любыми типами данных (вплоть до функций).

Идем дальше. Учтите, что в этом уроке мы будем настраивать вашу систему для работы и это не должно вас пугать. Погнали!

## Нода и пакетные менеджеры Нпм и Ярн

Для начала нам нужно поставить [Ноду](https://nodejs.org/en/) (Node.js): она выполняет джс-файлы не в браузере, а в виртуальном сервере.

#### Windows

Скачайте установщик с сайта [nodejs.org](https://nodejs.org/en/) и через него установите.

#### Unix

Поставьте из своих репозиториев: `apt-get`, `yum` и так далее.

#### macOS

Поставьте Ноду через команду `brew install node`.

---

В Ноде есть пакетный менеджер [npm](http://npmjs.com/). Кроме него, существует, например, [yarn](https://yarnpkg.com/), который по сути является аналогом для npm. Раньше yarn считался более быстрым и надежныи, чем npm, и все старались использовать его, однако со временем npm довели до ума и теперь нет необходимости использовать yarn. Но он может встречаться в некоторых проектах.

Что такое вообще пакетный менеджер и почему предсказуемость и скорость так важны?

* **Во-первых**, во время разработки вы будете использовать много сторонних модулей — ведь кучу вещей кто-то за вас уже когда-то написал, осталось это только подключить и использовать.

* **Во-вторых**, говоря про скорость: у каждого пакета могут быть свои зависимости (по 2-3), а в проекте, например, 100 зависимостей. Вместо 100 у вас устанавливается 300: 100 основных пакетов и их зависимостей. Может быть долго!

* **В-третьих**, пакеты соблюдают [Семвер](http://semver.org/) — семантичное версионирование. Дело в том, что пакеты обновляются, а ломать работающие приложения из-за этого не хочется, поэтому у нас есть версионирование `MAJOR.MINOR.PATCH` (например, Реакт сейчас — 18.2.0). `npm` раньше не уважал прописанные в `package.json` (основной файл проекта) версии и порою всё ломалось. По этой причине одно время использовали yarn.

> Стоит отметить, что у Ярна нет своей базы пакетов, он использует базу нпм.

---

Окей, Нпм поставили, Нода тоже стоит, всё замечательно. Тут я делаю уточнение: пакеты, которые ставятся через нпм/ярн могут быть **локальными** и **глобальными**. Ставятся они по-разному:

```sh
# поставить в систему
npm install -g <package_name>

# поставить локально в проект и записать в `package.json`
npm install <package_name>

# поставить локально и записать в package.devDependencies
npm install --save-dev <package_name>

# также можно использовать алиас, чтобы делать то же самое, но короче
npm i <package_name>
npm i -D <package_name>
```

Пакеты проекта в джс-мире описываются в файле [`package.json`](https://docs.npmjs.com/files/package.json) в секциях `dependencies` и `devDependencies`.

#### dependencies

Все зависимости, которые **используются в приложении**: Реакт, [normalize.css](https://necolas.github.io/normalize.css/) из курса по вёрстке, [react-day-picker](http://react-day-picker.js.org/) для работы с датами и другие.

#### devDependencies

Зависимости, которые **помогают работать приложению**: Еслинт, Преттир, Вебпак и другие.

Чтобы установить все пакеты проекта из `package.json`, есть команда `npm i` (алиас к `npm install`).

## Создание проекта

[Vite](https://vitejs.dev/) – это специальная штука, на которой можно быстро стартануть проект, использовав различные готовые шаблоны, такие как: `react-ts`, `vue-ts` или `svelte-ts` (или другие, в том числе без тайпскрипта).

Vite содержит уже готовые настройки для бандлера, Еслинта и тайпскрипта – о них мы поговорим в будущем.

Создайте проект `twitter-demo-frontend` командой:
```shell
npm create vite@latest twitter-demo-frontend -- --template react-ts
```

![](https://i.imgur.com/x1ybCUK.png)

Затем перейдите в созданный проект и запустите `npm install`
```shell
cd twitter-demo-frontend && npm install
```

Давайте взглянем на структуру директории:

![](https://i.imgur.com/MCHJxAZ.png)

* `.eslintrc.cjs` – конфиг Еслинта.
* `.gitignore` – если вы проходили [Гитхауту](https://githowto.com) из урока инструментов, вы знаете зачем нужен этот файл. Если нет — идите читать.
* `README.md` – сгенерированный ридми-файл с инструкциями как что запустить.
* `index.html` – рутовый html файл, куда мы будем встраивать Реакт приложение.
* `node_modules` — все модули проекта. Туда лезть никогда нельзя;
* `public` – лучше всего ответит документация: [The public directory](https://vitejs.dev/guide/assets.html#the-public-directory).
* `src` – директория, где вы пишете код.
* `package.json` — главный конфиг проекта, от него работают ярн и нпм;
* `package-lock.json` — файл npm'а, где он хранит информацию обо всех установленных пакетах проекта. Руками этот файл не редактируют, он генерируется сам.
* `tsconfig.json` и `tsconfig.node.json` – конфиги для тайпскрипта.
* `vite.config.ts` - конфиг для бандлера (у Vite под капотом rollup бандлер; бывают еще parcel и webpack)

> Я горячо рекомендую сначала прочитать [документацию](https://vitejs.dev/guide/) `Vite`: даже если вы не поймёте, это пассивные знания, которые могут всплыть, когда вам они понадобятся. В противном случае вы будете бегать с горящей жопой и не знать, что искать, когда возникнет проблема. Как вы понимаете, это правило универсально для всех инструментов, которые вы будете использовать. **Знайте свой инструмент.**

---

Окей, с этим разобрались. Запускаем проект через команду `npm run dev` и начинаем кодить.

![](https://i.imgur.com/gFAjFQY.png)

Запускаем браузер по указанному адресу и видим наш сайт:

![](https://i.imgur.com/384WOHr.png)

Открывайте в Вскоде `src/App.tsx` и узрите тот самый Джсх, который наконец-то работает!

## Настройка Вскода для проекта

Поставьте два плагина: [`dbaeumer.vscode-eslint`](https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint) и [`esbenp.prettier-vscode`](https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode).

### eslint

Плагин к [ESLint](http://eslint.org/). Еслинт — удобная утилита для проверки качества вашего кода. У него есть плагины и готовые конфиги, в [`Vite`](https://github.com/facebookincubator/create-react-app) ставится свой, достаточно мягкий.

### prettier

[Преттир](https://prettier.io/) это форматер кода. Больше никаких споров про отступы, переносы, запятые с точками и прочего.

### Настройки

Эти настройки идут в дополнение к вашим, а не полностью их заменяют. Разбирать их не буду, из значений, думаю, понятно что к чему относится, но если нет — не забудьте в чате прояснить.

```json
{
  "editor.tabSize": 2,
  "editor.defaultFormatter": "esbenp.prettier-vscode",
  "editor.formatOnSave": true,
  "editor.codeActionsOnSave": {
    "source.fixAll": "always",
    "source.organizeImports": "always"
  },
  "javascript.suggest.autoImports": true,
  "typescript.suggest.autoImports": true,
  "javascript.updateImportsOnFileMove.enabled": "always",
  "typescript.updateImportsOnFileMove.enabled": "always",
}
```

## Джс: импорты и экспорты

В 2015 году в Джсе появилась система импортов и экспортов. Если вкратце, то один файл может экспортнуть выражение, а второй — импортнуть. Это называется **модулями**.

В Джс экспорты бывают дефолтные и именованные.

### Дефолтные

```javascript
// sum.js
export default function(left, right) {
  return left + right;
}

// app.js
import sum from "./sum.js";

sum(1, 4); // 5
```

На самом деле, мы можем называть наш импорт как угодно:

```javascript
import fuckThis from "./sum.js";

fuckThis(1, 4); // 5
```

### Именованные

Но как быть, если вы хотите экспортнуть несколько констант или функций из одного файла? Для этого есть **именованные экспорты**.

```javascript
// math.js
export function sum(left, right) {
  return left + right;
}

export const divide = (left, right) => {
  return left / right;
};

export const mainNumber = 42;

// app.js
import { mainNumber, sum, divide } from "./math.js";

divide(mainNumber, sum(2, 4)); // 7
```

Джс сначала выполнит `sum(2, 4)`, который вернёт `6`, затем это число подставится как второй аргумент `divide`.

Здесь у нас нет роскоши именовать как угодно, но мы можем импортить `as`:

```
// app.js
import { mainNumber as myLovingNumber } from './math.js';
```

---

**Крайне желательно использовать только именованные экспорты, это считается best practice. Используйте дефолтные только тогда, когда это требуется явно, например, если библиотека использует их и только их для корректной работы, by design**.

## Модули работают через rollup

Rollup – это бандлер модулей под капотом у Vite. Когда создавали первые бандлеры, то разработчики подумали: а зачем нам копировать файлы, подключать всё в `index.html` по-старинке, если мы можем в джс-файлах импортить **вообще всё что угодно**?

![](https://i.imgur.com/HPLgX2D.png)

Кстати, при импорте директории бандлеры по-умолчанию лезут за `index.{js,jsx,ts,tsx}` файлом, поэтому не нужно писать `import Header from './Header/index.tsx`, да `.tsx` можно было бы опустить:

```tsx
import Header from "./Header";
```

## Реакт: функциональные компоненты

Окей, с импортами и экспортами разобрались, теперь нас интресует второй новый синтаксис:

```jsx
export const App = () => {
  return <div>My First React App</div>
}
```

Это самый простой компонент реакта. Если присмотреться, то это всего лишь стрелочная функция, которая возвращает джсх. И всё!

Если мы хотим сделать другой компонент и использовать его в этом, то делается это очень просто:
```jsx
const MyComponent = () => {
  return <div>Another component</div> 
}

export const App = () => {
  return (
    <div>
      <MyComponent />
    </div>
  )
}
```

Можно относиться к этому просто как к кускам верстки. Разумеется этот компонент мог бы спокойно лежать в другом файле, здесь просто для примера.
Обратите внимание, что компоненты обязаны называться с большой буквы, этим они отличаются от хтмл тегов.

## Реакт: классовые компоненты

Старый способ написания компонентов, но который все ещё иногда используется, выглядит так:
```jsx
class X extends React.Component {
  render() {
    return <div>Good old class component</div>
  }
}
```

Это классы, а если конкретнее — классовый компонент Реакта. Классовый компонент конкретно здесь идентичен функциональному: метод `render()` в классе тоже должен вернуть дерево элементов.

## Реакт: Джсх

Собственно, Джсх и отвечает за дерево элементов. Про Джсх мы говорили в четвертом уроке, давайте для примера переведём наше приложения про фильмы на Джсх и избавимся от `React.createElement`.

### Старый createElement

```jsx
// создаём компонент Img, который возвращает <img />
function Img(props) {
  return React.createElement("img", {
    className: props.className,
    src: props.src,
    alt: props.alt
  });
}

// создаём компонент Movie, который возвращает
// |---------| 2001: A Space Odyssey
// |---------|
// |---------|
// |---------|
// |---------|
// |_________|
function Movie(props) {
  return React.createElement(
    "div",
    { className: "movie-page" },
    // чилдреном может быть массив
    [
      // создаём элемент из компонента Img
      React.createElement(Img, {
        className: "movie-img",
        src: props.imgSrc,
        alt: props.title
      }),
      React.createElement("h1", { className: "movie-title" }, props.title)
    ]
  );
}

// создаём
const App = React.createElement(Movie, {
  title: "2001: A Space Odyssey",
  imgSrc: "https://i.imgur.com/vaZoNCA.jpg"
});

const root = document.getElementById("root");
if (root) {
  root.render(App);
}
```

### Новый Джсх

```jsx
// src/app.jsx
function Img(props) {
  return <img src={props.src} className={props.className} alt={props.alt} />;
}

export function Movie(props) {
  return (
    <div className="movie-page">
      <Img className="movie-img" src={props.imgSrc} alt={props.title} />
      <h1 className="movie-title">{props.title}</h1>
    </div>
  );
}
```

Аккуратнее стало? Намного!

---

Почему мы избавились от `root.render()`? Потому что этим занимается `src/index.js`.

В чём отличие `index.jsx` от `app.js`? `app.js` это главный файл **реакт**-приложения, а `index.js` — **фронтэнд**-приложения: в вашем проекте может быть много других сторонних библиотек, с которыми нужно будет работать.

## Итог

Урок получился большой, но в конце мы получили проект, с которым можно работать и для этого нам не нужно заниматься настройкой Вебпака.
В следующем уроке поговорим про тайпскрипт.
