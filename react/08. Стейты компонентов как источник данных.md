# Стейты компонентов как источник данных

Окей, с вёрсточкой разобрались: поняли, как верстать компонентами, переехали с селекторов на Стайлед-компонентс, поиграли с Реакт-роутером, но пора двигаться дальше.

Где хранить данные? Как с ними работать? Нужно ли писать сервис-провайдеры-фабрики как в Ангуларе?

## Стейты

Слава богу, не нужно! Реакт несложный даже в работе с данными и оперирует обычными функциями, которые возвращают новые данные.

Как работает Реакт? У компонента есть **стейт** — состояние данных, есть **рендер** — вёрстка, в сумме это то самое уравнение `ui = render(state)` из первого урока.

Что это значит? **Когда обновляется стейт, вызывается рендер и строится новый интерфейс**.

Да, само. Да, нужно всего лишь обновить стейт, рендер сам вызовется. Да, это так удобно.

Да, если вы хотите поставить кнопке красный цвет, не нужно писать `document.getElementById("my-button").style.background = 'red'`, достаточно просто поставить новый стейт.

Да, если вы хотите чекбоксу поставить `checked`, можно в стейт положить `checked: true` и передать пропом `checked={state.checked}`.

Да, в стейте можно хранить даже данные с сервера.

Да, в стейте хранят и данные заполненных форм.

Да, это работает как на маленьких проектах, так и на крупных.

Да, Редакс уже близко. Редакс это всего лишь глобальный стейт, а не компонентный.

### Посортируем список фильмов

Что такое стейт? Это просто объект с данными, к которому можно обратиться. При обновлении такого объекта специальной функцией реакт компонент перерендерится с новыми данными.

Для объявления стейта мы используем стандартный хук `useState` из реакта. Давайте объявим стейт, в котором будем хранить выбранную сортировку.

```tsx
// заранее объявим тип для Movie
interface Movie {
  id: number;
  title: string;
  year: number;
  rating: number;
}

// тип пропсов
interface MoviesListProps {
  movies: Array<Movie>;
}

// а также тип для стейта
// он будет включать только 3 значения
type SortBy = 'alphabetical' | 'date' | 'rating';

// рендерим
function MoviesList(props: MoviesListProps) {
  const [sortBy, setSortBy] = React.useState<SortBy>('alphabetical');
  
  return (
    <div>
      <p>Sort by:</p>
      <button>alphabetical</button>
      <button>date released</button>
      <button>average rating</button>
      ...movies list
    </div>
  );
}
```

В этом стейте мы можем хранить данные. Почему в стейте, а не просто константой? **Стейт — для динамических данных**, а в интерфейсе у нас есть сортировка фильмов.

Обновилась сортировка → обновился список фильмов → обновился интерфейс.

Теперь разберем детальнее эту строку:
```tsx
const [sortBy, setSortBy] = React.useState<SortBy>('alphabetical')
```

Хук `useState` возвращает массив, где первый элемент которого — значение стейта, а второй — функция, которая умеет обновлять это значение. Можно ли изменять стейт напрямую вот так: `sortBy = 'date'`? Нет, **нельзя**, это не будет работать. Для изменения стейта обязательно нужно вызвать `setSortBy('date')`.

Запись вида `const [first, second] = array` — это [деструктуризация массива](https://learn.javascript.ru/destructuring-assignment). Она используется просто для удобства. То же самое без деструктуризации можно записать так:
```typescript
const first = array[0];
const second = array[1];
```

А конкретно в нашем случае с `useState` было бы так:
```typescript
const state = React.useState<SortBy>('alphabetical')
const sortBy = state[0];
const setSortBy = state[1];
```

Выглядит всрато, не правда ли?

Окей, смотрим дальше. Дальше у нас идет вызов `useState`, в аргументы которого передается `'alphabetical'`. Это всего-навсего начальное значение стейта. Ещё туда можно передать функцию, которая вычисляет дефолтное значение, но обычно это редко используется, например, если у вас сложная логика инициализации стейта.

И наконец, так как у нас тайпскрипт, то мы указывем тип данных, которые лежат в стейте: `<SortBy>`. Без тайпскрипта можно было бы это просто не писать:
```jsx
const [sortBy, setSortBy] = React.useState('alphabetical')
```

Ну и разумеется, при деструктуризации мы можем называть значение и функцию для изменения как угодно:
```tsx
const [foo, bar] = React.useState(0);
```

Однако есть конвенция, по которой принято именовать так: `value` и `setValue`, где value — какое-то осмысленное имя. `index, setIndex`, `searchText, setSearchText`, `date, setDate` и так далее.

---

Предположим, что наш компонент используется где-то в приложении с такими пропсами, которые мы получили с бэкенда:
```tsx
const movies = [
  {
    id: 1,
    title: 'City Lights',
    year: 1931,
    rating: 8.5,
  },
  {
    id: 2,
    title: 'American History X',
    year: 1998,
    rating: 8.5,
  },
  {
    id: 3,
    title: 'Wild Strawberries',
    year: 1957,
    rating: 8.1,
  },
];

<MoviesList movies={movies} />
```

Для смены сортировки каждой кнопке мы добавим проп `onClick`, внутри которого будет функция, которая будет вызывать нашу функцию `setSortBy` и передавать туда поле, по которому нужно отсортировать.

```tsx
// рендерим
function MoviesList(props: MoviesListProps) {
  const [sortBy, setSortBy] = React.useState<SortBy>('alphabetical');

  return (
    <div>
      <p>Sort by:</p>
      <button onClick={() => setSortBy("alphabetical")}>alphabetical</button>
      <button onClick={() => setSortBy("date")}>date released</button>
      <button onClick={() => setSortBy("rating")}>average rating</button>
      ...movies list
    </div>
  );
}
```

Теперь напишем собственно саму функцию сортировки

```typescript
// заведём функцию сортировки
// https://davidwalsh.name/array-sort
function sortMoviesByField(field: keyof Movie, leftObject: Movie, rightObject: Movie): number {
  // так как строки в тайпскрипте сравниваются отлично от чисел, то мы здесь явно проверяем, что мы работаем по строками
  if (field === 'title') {
    return leftObject[field].localeCompare(rightObject[field]);
  }
  // остальные поля ('year' и `rating`) являются числами и их можно сравнить обычным вычитаением
  return leftObject[field] - rightObject[field];
}

// заведём объект,
// который будет приводить
// sortBy к конкретному полю у объекта movie
const sortFieldsToKey = {
  alphabetical: "title",
  date: "year",
  rating: "rating"
};
```

Что дальше? В рендере мы просто выведем эти фильмы через метод `.map()` у массива, предварительно их отсортировав.

Этот метод проходится по массиву, на каждом элементе вызывает функцию, которая должна вернуть новое значение под этим же индексом массива, в нашем случае — Реакт-компонент.

_Если тут ничего непонятно — перечитайте уроки про базовый джаваскрипт и базовый тайпскрипт._

```tsx
function MoviesList(props: MoviesListProps) {
  const [sortBy, setSortBy] = React.useState<SortBy>('alphabetical');

  return (
    <div>
      <p>Sort by:</p>
      <button onClick={() => setSortBy('alphabetical')}>alphabetical</button>
      <button onClick={() => setSortBy('date')}>date released</button>
      <button onClick={() => setSortBy('rating')}>average rating</button>

      {movies
        .toSorted((leftObj, rightObj) => {
          const field = sortFieldsToKey[sortBy];
          return sortMoviesByField(field, leftObj, rightObj);
        })
        .map((movie) => {
          return (
            <a key={movie.id} href={`/movies/${movie.id}`}>
              {movie.title} ({movie.year}) | rating {movie.rating}
            </a>
          );
        })}
    </div>
  );
}
```

> Что ещё за фигурные скобки? Это Джсх, в фигурных скобках [может быть](https://react.dev/learn/javascript-in-jsx-with-curly-braces) любое Джс-выражение: хоть `2 + 2`, хоть обращение к объекту `user.firstName`, хоть вызов функции `formatName(user)`.

> Что за проп `key`? Это [обязательный](https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key) у списков проп, который помогает Реакту отделить один компонент от другого при обновлении данных. Реакт справится и без них, но лучше с ними.

Мы же прошлись по массиву и получили новый массив, в котором есть Реакт-компоненты. Их мы и отрендерили.

В итоге мы будем рендерить список фильмов, а при клике на сортировку — сортировать его и автоматически обновлять стейт, потому что у нас есть специальная функция `setSortBy()`: от неё зависит Реакт и обновляет рендер сразу же после того как обновится стейт.

Кстати говоря, таких стейтов в компоненте может быть хоть сколько:
```tsx
const [state1, setState1] = React.useState(1);
const [state2, setState2] = React.useState(2);
const [state3, setState3] = React.useState(3);
const [state4, setState4] = React.useState(4);
```

---

Полный код этого урока выглядит так:
```tsx
// заранее объявим тип для Movie
interface Movie {
  id: number;
  title: string;
  year: number;
  rating: number;
}

// тип пропсов
interface MoviesListProps {
  movies: Array<Movie>;
}

// а также тип для стейта
// он будет включать только 3 значения
type SortBy = 'alphabetical' | 'date' | 'rating';

function MoviesList(props: MoviesListProps) {
  const [sortBy, setSortBy] = React.useState<SortBy>('alphabetical');

  return (
    <div>
      <p>Sort by:</p>
      <button onClick={() => setSortBy('alphabetical')}>alphabetical</button>
      <button onClick={() => setSortBy('date')}>date released</button>
      <button onClick={() => setSortBy('rating')}>average rating</button>

      {props.movies
        .toSorted((leftObj, rightObj) => {
          const field = sortFieldsToKey[sortBy];
          return sortMoviesByField(field, leftObj, rightObj);
        })
        .map((movie) => {
          return (
            <a key={movie.id} href={`/movies/${movie.id}`}>
              {movie.title} ({movie.year}) | rating {movie.rating}
            </a>
          );
        })}
    </div>
  );
}

const sortFieldsToKey: Record<SortBy, keyof Movie> = {
  alphabetical: 'title',
  date: 'year',
  rating: 'rating',
};

// заведём функцию сортировки
// https://davidwalsh.name/array-sort
function sortMoviesByField(field: keyof Movie, leftObject: Movie, rightObject: Movie): number {
  if (field === 'title') {
    return leftObject[field].localeCompare(rightObject[field]);
  }
  return leftObject[field] - rightObject[field];
}

```

## Итог

На этом наш урок подходит к концу.

Сегодня мы разобрались с тем, как у компонентов могут быть стейты, в которых хранятся и обновляются данные через `setState()`.

Важно помнить, что всю работу по обновлению интерфейса Реакт берёт на себя, наша задача — писать стейт, обновлять его и описать в рендере вёрстку от этого стейта.

Это был пример посложнее, чем бывает обычно в подобных туториалах, но такой пример несет больше пользы, чем бесконечные счетчики из примеров а-ля `const [count, setCount] = React.useState(0)`. Зачем вам в реальном приложении каунтер? А вот сортировка в реальном приложении всегда нужна.

Но тем не менее я настоятельно рекомендую прочитать [документацию про стейт реакта](https://react.dev/learn/state-a-components-memory).
