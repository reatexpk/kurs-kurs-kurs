# parcel как спасение наших душ
Как начать писать код уже сейчас, а не тратить 10 тысяч лет на настройку Вебпака

В прошлом уроке мы попробовали написать совсем крошечное приложение из трёх компонентов, но уже поняли, что с `createElement` это чертовски сложно — читаемость кода почти нулевая, конечно.

Тем не менее давайте освежим память прежде чем пойдём в инструменты, которые скроют от нас детали реализаций:

* Реакт — это чистый Джаваскрипт и работает на функции `React.createElement`;
* `React` это не рендерер, а библиотека для построения дерева элементов и его обновления, за это отвечает ВиртуалДОМ;
* За рендер в браузер отвечает библиотека `react-dom`, но бывают ещё `react-pdf`, `react-native` и другие;
* Реакт это компонентный подход, в котором для передачи данных используют пропы — атрибуты с любыми типами данных (вплоть до функций).

Идем дальше. Учтите, что в этом уроке мы будем настраивать вашу систему для работы и это не должно вас пугать. Погнали!

---

## Нода и пакетные менеджеры Нпм и Ярн

Для начала нам нужно поставить [Ноду](https://nodejs.org/en/) (Node.js): она выполняет джс-файлы не в браузере, а в виртуальном сервере.

#### Windows

Скачайте установщик с сайта [nodejs.org](https://nodejs.org/en/) и через него установите.

#### Unix

Поставьте из своих репозиториев: `apt-get`, `yum` и так далее.

#### macOS

Поставьте Ноду через команду `brew install node`.

---

В Ноде есть пакетный менеджер [npm](http://npmjs.com/). Кроме него, существует, например, [yarn](https://yarnpkg.com/), который по сути является аналогом для npm. Раньше yarn считался более быстрым и надежныи, чем npm, и все старались использовать его, однако со временем npm довели до ума и теперь нет необходимости использовать yarn. Но он может встречаться в некоторых проектах. 

Что такое вообще пакетный менеджер и почему предсказуемость и скорость так важны?

* **Во-первых**, во время разработки вы будете использовать много сторонних модулей — ведь кучу вещей кто-то за вас уже когда-то написал, осталось это только подключить и использовать.

* **Во-вторых**, говоря про скорость: у каждого пакета могут быть свои зависимости (по 2-3), а в проекте, например, 100 зависимостей. Вместо 100 у вас устанавливается 300: 100 основных пакетов и их зависимостей. Может быть долго!

* **В-третьих**, пакеты соблюдают [Семвер](http://semver.org/) — семантичное версионирование. Дело в том, что пакеты обновляются, а ломать работающие приложения из-за этого не хочется, поэтому у нас есть версионирование `MAJOR.MINOR.PATCH` (например, Реакт сейчас — 18.2.0). `npm` раньше не уважал прописанные в `package.json` (основной файл проекта) версии и порою всё ломалось. По этой причине одно время использовали yarn.

> Стоит отметить, что у Ярна нет своей базы пакетов, он использует базу нпм.

---

Окей, Нпм поставили, Нода тоже стоит, всё замечательно. Тут я делаю уточнение: пакеты, которые ставятся через нпм/ярн могут быть **локальными** и **глобальными**. Ставятся они по-разному:

```sh
# поставить в систему
npm install -g <package_name>

# поставить локально в проект и записать в `package.json`
npm install <package_name>

# поставить локально и записать в package.devDependencies
npm install --save-dev <package_name>

# также можно использовать алиас, чтобы делать то же самое, но короче
npm i <package_name>
npm i -D <package_name>
```

Пакеты проекта в джс-мире описываются в файле [`package.json`](https://docs.npmjs.com/files/package.json) в секциях `dependencies` и `devDependencies`.

#### dependencies

Все зависимости, которые **используются в приложении**: Реакт, [normalize.css](https://necolas.github.io/normalize.css/) из курса по вёрстке, [react-day-picker](http://react-day-picker.js.org/) для работы с датами и другие.

#### devDependencies

Зависимости, которые **помогают работать приложению**: Еслинт, Преттир, Вебпак, Парсель и другие.

Чтобы установить все пакеты проекта из `package.json`, есть команда `npm i` (алиас к `npm install`).

---

## Бандлеры

### Что такое бандлеры и зачем они нужны?

Бандлеры (от англ. to bundle – связывать) это такие программы, которые берут весь наш код в разных файлах, оптимизируют его,
минифицируют и сжимают, удаляют неиспользуемый код и на выходе запаковывают, то есть связывают все в один `index.html`, один `index.css` и один `index.js` + картинки.
Дальше мы можем просто открыть `index.html` и увидеть наше работающее приложение. Гораздо удобнее, чем руками все подключать.
Вместо этого мы один раз подключили джс файл и добавили его в `index.html`. А уже в джс файлах мы можем импортировать **вообще всё что угодно**.

![](https://i.imgur.com/3oQKttO.png)
*Примерная схема, как работают бандеры*

### Какие бывают бандлеры?

[Parcel](https://parceljs.org/) это один из бандлеров, который из коробки, без всякой конфигурации умеет работать с
джаваскриптом, тайпскриптом, различными CSS препроцессорами, такими как SASS и LESS, да и много с чем еще. Ставишь
и сразу пишешь код, не тратя 100500 часов на настройку, удобно. Но конечно при желании и его можно настроить для себя.

[Rollup](https://rollupjs.org/) – особо его не использовал, но думаю, что он примерно такой же как и парсель. В чистом виде его наверно никто не использует.
А вот, например, [Vite](https://vitejs.dev/) (что-то вроде надстройки над роллапом, роллап на стероидах) его использует под капотом.
В принципе Vite тоже хороший вариант для старта.

[Webpack](https://webpack.js.org/) тоже бандлер, но его нужно специально настраивать, писать конфиги и вручную
подключать лоадеры, чтобы научить его работать с теми или иными файлами (сам он ничего не умеет, у него лапки).
Вебпак очень гибкий, его можно довольно
тонко настроить конкретно под свои нужды. Также у вебпака огромное коммьюнити и куча гайдов в интернете, он
используется во многих крупных компаниях. До недавнего времени это был, можно сказать, стандарт во фронтенде.
Однако из-за сложности настройки это не самый лучший выбор для новичков. Поэтому мы возьмем парсель.

### create-react-app
Раньше была такая штука, как [create-react-app](https://create-react-app.dev/). У нее под капотом был вебпак, а ее фишкой было то,
что одной командой можно было развернуть рабочее фронтенд приложение, с линтерами и с готовыми конфигами, которые спрятаны от разработчика.
Такой а-ля преднастроенный проект. Но его уже год или больше не обновляли, а на гитхабе висит 1.7k issues. Так что он скорее мертв, чем жив.

---

## Создание проекта

Создайте директорию `twitter-demo-frontend`, ней инициализируйте git и npm:
```shell
mkdir twitter-demo-frontend && cd twitter-demo-frontend
git init
npm init -y # флаг -y заполняет package.json дефолтными значениями
```

Перед тем, как ставить зависимости, добавим файл `.gitignore` со следующим содержимым:
```
node_modules
dist
.parcel-cache
.vscode
.idea
```

Это нужно, чтобы наш репозиторий не засрался кучей библиотек, которые мы сейчас будем ставить,
локальными настройками ваших редакторов и прочими вещами, которых не должно быть в репозитории,
такими как кэш.

Затем сразу же поставим parcel:
```shell
npm i --save-dev parcel
```

Давайте взглянем на структуру проекта:

```sh
/private/tmp $ ls -al twitter-demo-frontend
total 752
e     Mar  3 22:38 .
e     Mar  3 22:37 ..
e     Mar  3 22:38 .gitignore
e     Mar  3 22:38 node_modules
e     Mar  3 22:38 package.json
e     Mar  3 22:38 package-lock.json
```

* `.gitignore` если вы проходили [Гитхауту](https://githowto.com) из урока инструментов, вы знаете зачем нужен этот файл. Если нет — идите читать.
* `node_modules` — все модули проекта. Туда лезть никогда нельзя;
* `package.json` — главный конфиг проекта, от него работают ярн и нпм;
* `package-lock.json` — файл npm'а, где он хранит информацию обо всех установленных пакетах проекта. Руками этот файл не редактируют, он генерируется сам.
* `src` — этой директории пока нет, но мы ее сейчас создадим.
* `dist` — этой директории пока нет, но она создастся сама при билде приложения. В ней будет лежать наше приложение в скомпилированном виде и туда нам залазить не надо.
* `.parcel-cache` — этой директории пока нет, но она создастся сама при первом старте приложения. Это кэш парселя и туда нам залазить не надо.

> Я горячо рекомендую сначала прочитать [документацию](https://parceljs.org/getting-started/webapp/) `parcel`: даже если вы не поймёте, это пассивные знания, которые могут всплыть, когда вам они понадобятся. В противном случае вы будете бегать с горящей жопой и не знать, что искать, когда возникнет проблема. Как вы понимаете, это правило универсально для всех инструментов, которые вы будете использовать. **Знайте свой инструмент.**

---

Окей, с этим разобрались. Осталось создать директорию `src`, в которой будет лежать весь наш код.
Для начала положим туда обычный `index.html`
```html
<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8"/>
    <title>My First Parcel App</title>
  </head>
  <body>
    <h1>Hello, World!</h1>
  </body>
</html>
```

Теперь пойдем в `package.json`, заменим дефолтную строчку `"main": "index.js"` на `"source": "src/index.html"` и добавим такие скрипты:
```json
"scripts": {
  "start": "parcel",
  "build": "parcel build"
},
```

Запускаем проект через команду `npm start` и начинаем кодить.

![](https://i.imgur.com/5sD8WaZ.png)

Запускаем браузер по указанному адресу и видим наш сайт:

![](https://i.imgur.com/H6XL6s1.png)

Сейчас это просто `index.html`, никакого жса тут нет. Поэтому подключим его. Создайте рядом с `index.html` файл `index.jsx` со следующим содержимым:
```jsx
import React from 'react';
import { createRoot } from 'react-dom/client';

const rootElement = document.getElementById('root');
if (rootElement) {
  const root = createRoot(rootElement);
  root.render(<div>My First React App</div>)
}
```

---

> Расширения `.js` и `.jsx` отличаются тем, что в случае `.jsx` мы также разрешаем использование Джсх в этом файле. Джсх в `.js` файлах работать не будет. А ещё тем самым мы по названию файла можем понять, что это реакт компонент, а не просто джс код.

Про импорты поговорим чуть позже, сейчас можно просто это скопировать себе. Кстати об импортах, а откуда импортируем? А ниоткуда, мы же не установили реакт! Давайте установим:
```shell
npm i react react-dom
```

Чтобы отрендерить наш Джсх, в самом `index.html` меняем `<h1>Hello, World!</h1>` на специальный контейнер, к которому мы обращаемся в `index.jsx` – `<div id="root"></div>`, а в конце тега `body` добавляем наш скрипт. Получится в итоге так:
```html
<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <title>My First Parcel App</title>
  </head>
  <body>
    <div id="root"></div>
    <script src="./index.jsx" type="module"></script>
  </body>
</html>
```

Смотрим, что у нас там получилось.

![](https://i.imgur.com/YHBIn4i.png)

Всё работает! Кстати, вы заметили, что страницу браузера мы ни разу не обновляли вручную?
Это все потому что `parcel` предоставляет нам дев-сервер с автоматической заменой кода.
Можете изменить строку `My First React App` на что-нибудь другое и сохранить и увидите, как оно автоматом появится в браузере.

> `index.jsx` в данном случае является входной точкой для нашего приложения. Обычно тут можно импортировать что-то глобальное, например, какие-то глобальные CSS стили

---

Конечно мы не можем весь код приложения держать в одном файле (точнее можем в теории, но зачем нам файл на 100500 строк?).
Поэтому мы делим наше приложение на модули, чтобы было удобнее работать. Давайте рядом с `index.jsx` создадим файл `app.jsx` и вынесем туда наш джсх из `index.jsx`:
```jsx
export const App = () => {
  return <div>My First React App</div>
}
```

А в `index.jsx` импортируем и заюзаем (_расширение для джс файлов можно не указывать_):
```jsx
import React from 'react';
import { createRoot } from 'react-dom/client';

import { App } from './app';

const rootElement = document.getElementById('root');
if (rootElement) {
  const root = createRoot(rootElement);
  root.render(<App />)
}
```

Вернемся в браузер и проверим, что ничего не сломалось:
![](https://i.imgur.com/YHBIn4i.png)

Теперь нужно разобраться, что за код мы вообще написали: импорты и экспорты это нечто новое.

---

## Джс: импорты и экспорты

В 2015 году в Джсе появилась система импортов и экспортов. Если вкратце, то один файл может экспортнуть выражение, а второй — импортнуть. Это называется **модулями**.

В Джс экспорты бывают дефолтные и именованные.

### Дефолтные

```javascript
// sum.js
export default function(left, right) {
  return left + right;
}

// app.js
import sum from "./sum.js";

sum(1, 4); // 5
```

На самом деле, мы можем называть наш импорт как угодно:

```javascript
import fuckThis from "./sum.js";

fuckThis(1, 4); // 5
```

### Именованные

Но как быть, если вы хотите экспортнуть несколько констант или функций из одного файла? Для этого есть **именованные экспорты**.

```javascript
// math.js
export function sum(left, right) {
  return left + right;
}

export const divide = (left, right) => {
  return left / right;
};

export const mainNumber = 42;

// app.js
import { mainNumber, sum, divide } from "./math.js";

divide(mainNumber, sum(2, 4)); // 7
```

Джс сначала выполнит `sum(2, 4)`, который вернёт `6`, затем это число подставится как второй аргумент `divide`.

Здесь у нас нет роскоши именовать как угодно, но мы можем импортить `as`:

```
// app.js
import { mainNumber as myLovingNumber } from './math.js';
```

---

**ВАЖНО: всегда нужно использовать только именованные экспорты, это считается best practice. Используйте дефолтные только тогда, когда с именованными не работает by design**.

Кстати, при импорте директории Parcel по-умолчанию лезет за `index.js` или `index.jsx` файлом, поэтому не нужно писать `import Header from './Header/index.js`, да `.js` можно было бы опустить:

```js
import Header from "./Header";
```

---

## Реакт: функциональные компоненты

Окей, с импортами и экспортами разобрались, теперь нас интресует второй новый синтаксис:

```jsx
export const App = () => {
  return <div>My First React App</div>
}
```

Это самый простой компонент реакта. Если присмотреться, то это всего лишь стрелочная функция, которая возвращает джсх. И всё!

Если мы хотим сделать другой компонент и использовать его в этом, то делается это очень просто:
```jsx
const MyComponent = () => {
  return <div>Another component</div> 
}

export const App = () => {
  return (
    <div>
      <MyComponent />
    </div>
  )
}
```

Можно относиться к этому просто как к кускам верстки. Разумеется этот компонент мог бы спокойно лежать в другом файле, здесь просто для примера.
Обратите внимание, что компоненты обязаны называться с большой буквы, этим они отличаются от хтмл тегов.

---

## Реакт: классовые компоненты

Старый способ написания компонентов, но который все ещё иногда используется, выглядит так:
```jsx
class X extends React.Component {
  render() {
    return <div>Good old class component</div>
  }
}
```

Это классы, а если конкретнее — классовый компонент Реакта. Классовый компонент конкретно здесь идентичен функциональному: метод `render()` в классе тоже должен вернуть дерево элементов.

---

## Реакт: Джсх

Собственно, Джсх и отвечает за дерево элементов. Про Джсх мы говорили в четвертом уроке, давайте для примера переведём наше приложения про фильмы на Джсх и избавимся от `React.createElement`.

### Старый createElement

```jsx
// создаём компонент Img, который возвращает <img />
function Img(props) {
  return React.createElement("img", {
    className: props.className,
    src: props.src,
    alt: props.alt
  });
}

// создаём компонент Movie, который возвращает
// |---------| 2001: A Space Odyssey
// |---------|
// |---------|
// |---------|
// |---------|
// |_________|
function Movie(props) {
  return React.createElement(
    "div",
    { className: "movie-page" },
    // чилдреном может быть массив
    [
      // создаём элемент из компонента Img
      React.createElement(Img, {
        className: "movie-img",
        src: props.imgSrc,
        alt: props.title
      }),
      React.createElement("h1", { className: "movie-title" }, props.title)
    ]
  );
}

// создаём
const App = React.createElement(Movie, {
  title: "2001: A Space Odyssey",
  imgSrc: "https://i.imgur.com/vaZoNCA.jpg"
});

const root = document.getElementById("root");
if (root) {
  root.render(App);
}
```

### Новый Джсх

```jsx
// src/app.jsx
function Img(props) {
  return <img src={props.src} className={props.className} alt={props.alt} />;
}

export function Movie(props) {
  return (
    <div className="movie-page">
      <Img className="movie-img" src={props.imgSrc} alt={props.title} />
      <h1 className="movie-title">{props.title}</h1>
    </div>
  );
}
```

Аккуратнее стало? Намного!

---

Почему мы избавились от `root.render()`? Потому что этим занимается `src/index.js`.

В чём отличие `index.jsx` от `app.js`? `app.js` это главный файл **реакт**-приложения, а `index.js` — **фронтэнд**-приложения: в вашем проекте может быть много других сторонних библиотек, с которыми нужно будет работать.

## Итог

Урок получился большой, но в конце мы получили проект, с которым можно работать и для этого нам не нужно заниматься настройкой Вебпака.
В следующем уроке поговорим про тулинг.
