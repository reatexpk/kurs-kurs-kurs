# Паттерны: от Higher-Order Components до Render Props
Вместо собственных велосипедов давайте использовать уже готовые подходы

# Паттерны Реакта

> Вместо собственных велосипедов давайте использовать уже готовые подходы

## [Conditional Rendering](https://reactjs.org/docs/conditional-rendering.html)

Начнём, на удивление, с самого простейшего вопроса: как отрендерить кусок в зависимости от проверки?

Как вы помните, Джсх это всё равно что Джс, поэтому в самом примитивном варианте просто вставьте ифы и ретёрны.

### Примитивный вариант

```jsx
if (x) return <TruthyComp />;

// вернется если проверка на x
// не отработала в true
return <FalsyComp />;
```

Ну или тернарный оператор `?:`

```jsx
return x ? <TruthyComp /> : <FalsyComp />;
```

### [Инлайновые проверки](https://reactjs.org/docs/conditional-rendering.html#inline-if-with-logical--operator)

Что делать, если у вас большой компонент (не надо так) и нужно по условию отрендерить какой-то блок внутри Джсх? Допустим, кнопку. Просто поместите проверку через оператор `&&` в `{}`.

```jsx
function Mailbox(props) {
  const unreadMessages = props.unreadMessages;
  return (
    <div>
      <h1>Hello!</h1>
      {unreadMessages.length > 0 && (
        <h2>You have {unreadMessages.length} unread messages.</h2>
      )}
    </div>
  );
}
```

Как замечено в официальной документации, такое возможно, потому что в Джаваскрипте выражение `true && expression` выполнит `expression`, а `false && expression` выполнит `false`.

То же самое с `if else` работать не будет, только тернарники работают
```tsx
function Mailbox(props) {
  const unreadMessages = props.unreadMessages;
  return (
    <div>
      <h1>Hello!</h1>
      {if (unreadMessages.length > 0) { // Так делать нельзя!
         return <h2>You have {unreadMessages.length} unread messages.</h2>
       } else {
         return <h2>You have no unread messages.</h2>
       }
      }
    </div>
  );
}
```

## Children-as-a-function или render prop

Чилдрен может быть функцией. Знали?

```jsx
function Auth(props) {
  const [isLoggedIn, setLoggedIn] = React.useState(false);
  const [userId, setUserId] = React.useState(1);
  
  return props.children({ isLoggedIn, userId });
}

function Lesson(props) {
  return (
    <View>
      <h1>{props.title}</h1>

      <Auth>
        {function({ isLoggedIn, userId }) {
          if (isLoggedIn) {
            return props.lesson;
          }

          // возвращаем превью урока если человек не залогинен
          return props.preview;
        }}
      </Auth>
    </View>
  );
}
```

## [Higher-order Component](https://reactjs.org/docs/higher-order-components.html)

Ещё один способ передать пропы из одного компонента в другой: HoC.

HoC — это функция, в которую приходит компонент и которая возвращает другой компонент, но уже с какой-то новой логикой.

```jsx
function withAuth(Component, options = {}) {
  // WrappedComponent — это компонент-обертка с какой-то дополнительной логикой
  // в нашем случае этой логикой будет стейт авторизации
  const WrappedComponent = () => {
    const [isLoggedIn, setLoggedIn] = React.useState(false);
    const [userId, setUserId] = React.useState(1);
    
    // передаем дополнительную логику в изначальный компонент
    return <Comp isLoggedIn={isLoggedIn} userId={userId} />;
  }
  
  // возвращаем наш улучшенный компонент
  return WrappedComponent;
}

function Lesson(props) {
  return (
    <View>
      <h1>{props.title}</h1>

      {props.isLoggedIn ? props.lesson : props.preview}
    </View>
  );
}

const LessonWithAuth = withAuth(Lesson);
```

В чём отличие от рендер пропа? В том, что менее явное поведение: в рендер пропе обычная функция с набором аргументов, а тут в пропы нашего компонента спускаются неизвестные пропы.

## Родитель-ребенок

Здесь оставлю ссылку на [пост](https://medium.com/@jmuse/d86394da2b50) Юли, которая проходила курс: она расписала модели «родитель → ребенок», «ребенок → родитель» и «ребенок → ребенок».

## Кастомные хуки

С появлением хуков в реакте появилась возможность создавать свои хуки. Покажу на аналогичном примере с авторизацией.

```tsx
function useAuthState() {
  const [isLoggedIn, setLoggedIn] = React.useState(false);
  const [userId, setUserId] = React.useState(1);
  
  React.useEffect(() => {
    // Здесь же можно пользоваться всеми хуками реакта
    // Например, сделать какой то запрос в эффекте
  }, []);
  
  // Или определить метод
  const logout = React.useCallback(() => {
    setUserId(null);
  }, [])
  
  // возвращаем нужное
  return { userId, isLoggedIn, logout }
}

function Lesson(props) {
  const authState = useAuthState();
  
  // Где нибудь тут можно вызвать тот самый логаут
  // const logout = authState.logout;
  
  return (
    <View>
      <h1>{props.title}</h1>

      {authState.isLoggedIn ? props.lesson : props.preview}
    </View>
  );
}
```

Таким образом можно выносить части с логикой в отдельные хуки и разгружать жирные компоненты. Кроме того, хуки можно переиспользовать в других местах.

## Итог

Паттерны нужны, чтобы не плодить свои велосипеды и не усложнять себе (и другим разработчикам!) жизнь.
