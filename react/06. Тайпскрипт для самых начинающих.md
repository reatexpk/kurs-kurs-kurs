# Тайпскрипт для самых начинающих

Теперь настало время поговорить про тайпскрипт. Что же такое тайпскрипт и зачем он нужен? Сейчас объясню!

## Суть

Вообще тайпскрипт – это надмножество джаваскрипта. Это означает, что любой синтаксически валидный джаваскрипт код является также валидным тайпскрипт кодом (с точки зрения его выполнения), но код может провалить проверку на типы. 

Что это значит? Например, у нас есть такой джаваскрипт код на обычном ванильном (без фреймворков) джаваскрипте:
```javascript
function hideElement(element) {
  element.classList.remove('visible')
  element.classList.add('hidden')
}

const menuElement = document.getElementById('menu')
const closeMenuButton = document.getElementById('close-menu-button')

closeMenuButton.onclick = () => hideElement(menuElement)
```

Ну тут в принципе все понятно: по клику на кнопку-крестик закрытия меню, срабатывает событие `onclick`, которое закрывает меню.

И это будет работать. Но если кто-то поменяет айдишник нашего меню с `id="menu"` на `id="sidebar-menu"`, то код упадет с ошибкой `Uncaught TypeError: Cannot read properties of null (reading 'classList')`.

Почему так произошло довольно очевидно: мы не смогли найти элемент с айди `menu`, получили `null`, а потом у него попытались обратиться к свойству `classList`. Естественно, что у `null` нет никаких свойств. Об том и ошибка.

Если бы мы писали код на тайпскрипте, то он выглядел бы так:
```typescript
function hideElement(element: HTMLElement | null) {
  element?.classList.remove('visible')
  element?.classList.add('hidden')
}

const menuElement = document.getElementById('menu')
const closeMenuButton = document.getElementById('close-menu-button')

closeMenuButton.onclick = () => hideElement(menuElement)
```

По тайпскрипт аннотации к функции `document.getElementById` видно, что она может возвращать тип `HTMLElement` либо `null`. `null` будет в том случае, если элемента с таким айди на странице не нашлось.
И затем именно этот тип – `HTMLElement | null` – будет указан для аргумента функции `hideElement`. То есть теперь мы ожидаем, что нам в `hideElement` прилетит ЛИБО `HTMLElement`, ЛИБО `null`.
Получается, что изначальный код на Джсе был подвержен багу, при котором мы не учли кейс с `null` и о котором мы даже не задумывались при написании кода.
А дальше мы можем следовать подсказкам тайпскрипта прямо из Вскода, который нам любезно сообщит, что `TS18047: 'element' is possibly 'null'.`.
Чтобы пофиксить это, мы можем добавить [optional chaining](https://learn.javascript.ru/optional-chaining) внутри функции `hideElement`. А еще лучше добавить какой-то ворнинг, чтобы если что узнать о проблеме, например так:
```typescript
function hideElement(element: HTMLElement | null) {
  if (!element) {
    console.warn('Element is null, nothing to hide')
  }
  element.classList.remove('visible')
  element.classList.add('hidden')
}
```

На первый взгляд может показаться, что это сложнее, чем просто обычный джаваскрипт – ещё какие-то типы нужно указывать, что за бред?

Но по факту, если бы у нас с самого начала стоял тайпскрипт, то мы бы:
1. Узнали бы, что мы пропустили один кейс, приводящий к багу, на этапе разработки, а не когда нашим сайтом УЖЕ пользуются клиенты, которые потом начнут обрывать техподдержку "а чё у меня ничего не работает? ААА?";
2. Сразу бы пофиксили этот баг, используя подсказки и автокомплит от тайпскрипта;
3. Один раз указали бы типы и забыли, зато когда вернулись бы к этому коду через полгода, то ничего не сломали бы, т.к. тайпскрипт подскажет, если что-то не так;
4. По типам легче ориентироваться в коде: нам необязательно знать, что именно делает функция внутри (ее реализацию), достаточно знать, какие аргументы она принимает и какой тип возвращает;
5. Удобно писать в Вскоде `document.` и сразу видеть какие методы у него можно вызвать;
6. Защищает от опечаток типа `document.getElementByDi` – `TS2551: Property 'getElementByDi' does not exist on type 'Document'. Did you mean 'getElementById'?`.
---
7. (БОНУСНЫЙ ПУНКТ) На собеседованиях, когда спрашивают, что выдаст код `console.log([] + {})`, можем отвечать, что `TS2365: Operator '+' cannot be applied to types 'never[]' and '{}'.`

В общем, нормальные приложения чуть сложнее hello world без тайпскрипта не пишутся – это стандарт.

## Базовый синтаксис

С сутью разобрались, теперь посмотрим как же писать типы.

### Примитивные типы

Существует несколько примитивных типов, их можно записать после имени переменной вот так

```typescript
const a: number = 1 // Примечание: NaN тоже типа number, нужно это всегда иметь в виду и проверять отдельно функцией Number.isNaN()
const b: string = 'Typescript is cool'
const c: boolean = true
const d: null = null
const e: undefined = undefined
```

Если мы сразу же присваиваем значение этого типа переменной, то тип можно не указывать – он выведется сам.

Но если мы пишем тип для аргументов функции, то тип указывать обязательно, так как его неоткуда вывести:

```typescript
function sum(a: number, b: number) {
  return a + b
}
```

А вот тип, который возвращает функция, указывать необязательно – его тайпскрипт выведет сам по коду внутри функции. Но при желании можно указать и самому вот так:

```typescript
function sum(a: number, b: number): number {
  return a + b
}
```

Для стрелочных функций это выглядит так:

```typescript
const sum = (a: number, b: number): number => a + b
```

### Сложные типы

С примитивами разобрались, теперь посмотрим на сложные типы для массивов, объектов и классов.

#### Объекты

Допустим мы хотим типизировать такой объект:

```javascript
const user = {
  id: 1,
  firstName: 'John',
  lastName: 'Doe',
  isOnline: true,
}
```

Для этого пишем такой интерфейс, который описывает этот объект, используя вышеупомянутые примитивные типы

```typescript
interface User {
  id: number;
  firstName: string;
  lastName: string;
  isOnline: boolean;
}
```

И затем назначаем этот тип объекту, так же как и примитив

```typescript
const user: User = {
  id: 1,
  firstName: 'John',
  lastName: 'Doe',
  isOnline: true,
}
```

#### Массивы

Вряд ли у вас будет 1 пользователь в приложении, скорее всего их будет много. Тогда нам нужно положить всех пользователей в массив и указать правильный тип. Делается это так:

```typescript
const users: Array<User> = [
  {
    id: 1,
    firstName: 'John',
    lastName: 'Doe',
    isOnline: true,
  },
  {
    id: 2,
    firstName: 'Foo',
    lastName: 'Bar',
    isOnline: false,
  }
]
```

Здесь мы взяли дженерик тип `Array` и передали ему тип `User`, получили массив юзеров.

> Дженерик тип это специальный обобщающий тип, в который можно передать другой тип (как аргументы в функцию). Конкретно в примере выше, если мы вызовем у массива `users.map((user) => {})`, то тайпскрипт уже будет знать, что тип у `user` – `User`. Подробнее об этом будет рассказано позже.

Есть ещё одна запись такого же типа: `User[]` это то же самое, что и `Array<User>`. Почему лучше писать `Array<Type>`? Потому что при вложенных типах это легче читается. Вот [тут](https://tkdodo.eu/blog/array-types-in-type-script) есть хорошее объяснение.

#### Классы

С классами практически все точно так же, как и с объектами. Можно описать интерфейс и заимплементить его:

```typescript
interface Dismissable {
  dismiss: () => void; // про void будет дальше
}

class YourClass implements Dismissable {}
```

После этого тайпскрипт будет ругаться, что вы не написали метод `dismiss`, который должен быть, так как класс имплементит тип с таким методов: `Property dismiss from interface Dismissable is not implemented`
Добавим его

```typescript
class YourClass implements Dismissable {
  dismiss() {
    // do something here
  }
}
```

Теперь не ругается, кайф! На самом деле для классов необязательно указывать типы через `implements`, можно определять их сразу в классе, например так:

```typescript
class YourClass {
  foo: number; // для полей класса нужно явно указывать тип

  constructor(foo: number) {
    this.foo = foo; // иначе тут будет ошибка `TS2339: Property 'foo' does not exist on type 'YourClass'.`
  }

  // А вот методы просто пишем, как обычные функции
  dismiss() {
    // do something here
  }
}
```

### Другие типы

В принципе того, что выше, уже хватит, чтобы писать код на тайпскрипте на базовом уровне. Однако есть ещё кое-что.

#### Дженерик типы

Тут скорее проще показать, чем рассказать. Это работает примерно как джс функции.

```typescript
// Допустим у нас есть какие-то заказы, определяем тип для заказа
interface Order {
  id: string;
  orderNumber: string;
  date: string;
  customerId: string;
  total: number;
  isCompleted: boolean;
}

// Пишем асинхронную функцию, которая сходит на бэк по урлу и вернет нам какие-то данные
async function fetchData<T>(url: string): Promise<T> {
  try {
    const response = await fetch(url);
    const data: T = await response.json(); // здесь мы никак не можем вывести тип для data, поэтому указываем его сами (при этом мы даже не знаем, что тут за тип, он динамический)
    return data;
  } catch (error) {
    return Promise.reject(error);
  }
}

async function getOrderById(orderId: string) {
  const data = await fetchData<Order>(`/orders/${orderId}`);
     // ^ здесь data определяется тайпскриптом как Order
}
```

Здесь функция `fetchData` – универсальная, ей неважно какие данные она получает с бэка, она просто умеет это делать. Это могут быть хоть заказы, хоть юзеры, что угодно. Ей для работы нужен только урл, а с самими данными она никак не взаимодействует, только возвращает их.
И именно потому, что ей без разницы на тип данных, мы делаем этот тип динамическим, называем его просто `T`, кладем между названием функции и агрументами в `<T>`, а функция возвращает промис с этим самым динамическим типом. `T` – это как переменная тут.

Затем, если нужно запросить с бэка не заказы, а, скажем, юзеров, то мы делаем так:

```typescript
async function getUserById(userId: string) {
  const data = await fetchData<User>(`/users/${userId}`);
     // ^ здесь data определяется тайпскриптом как User
}
```

Это и есть дженерик типы или просто дженерики.

> Кстати `Promise<Order>` и `Promise<User>` – это точно такие же дженерики. Тип `Promise` никак не меняет данные, а только предоставляет методы `then`, `catch` и `finally`, в которые подсовывает вами же указанный тип данных.

#### Utility types

В тайпскрипте есть несколько встроенных служебных типов для разных задач. Их не нужно импортировать, можно просто использовать. Их много, они разные и очень полезные, но я на них останавливаться не буду. Подробнее о них можно почитать в документации тайпскрипта: [Utility types](https://www.typescriptlang.org/docs/handbook/utility-types.html).

Могу сказать только, что очень часто используются `Record`, `Pick`, `Omit` и `Partial`. Из нужно знать обязательно.

#### Вспомогательные типы

Я ранее обещал, что расскажу про тип `void`. Рассказываю.

Есть несколько типов, которые как бы отдельно живут, но тоже довольно часто встречаются.

##### void

`void` это по сути просто ничего. Но, погоди-ка, ничего это же `undefined`? Да, но тут прямо совсем-совсем ничего. Когда используется `void`, то нам вообще наплевать какой это тип, потому что мы его никак не используем (и не можем, это же ничего). В 99% случаев `void` используется при описании функций, которые ничего не возвращают.

```typescript
function log(message: string): void {
  console.log(message)
  // кроме консоль лога тут ничего нет, функция ничего не возвращает, у нее даже return нету
}
```

##### unknown

`unknown` – это неизвестный тип. В нем может быть что угодно: объект, `null`, массив, число – вообще что угодно. Поэтому перед любыми манипуляциями с таким типов нужно обязательно проверять тип. Например:

```typescript
function doSomething(foo: unknown) {
  console.log(foo.bar) // 🚫 Ошибка: неизвестно, есть ли у foo поле bar, может foo это null?
  if ('bar' in foo) {
    console.log(foo.bar) // ✅ Так правильно: проверили, есть ли у foo поле bar
  }
  
  foo.forEach((item) => console.log(item)) // 🚫 Ошибка: неизвестно, foo массив или нет? Есть ли у него метод forEach?
  if (Array.isArray(foo)) {
    foo.forEach((item) => console.log(item)) // ✅ Так правильно: проверили, что foo это массив
  }
  
  console.log(foo + 1) // 🚫 Ошибка: неизвестно, foo число или нет? Можно ли ему безопасно прибавить 1?
  if (typeof foo === 'number') { // ✅ Так правильно: проверили, что foo это число
    if (Number.isNaN(foo)) { // ✅ Так правильно: не забыли, что NaN это тоже тип number и дополнительно проверили (NaN + 1 = NaN)
      console.log(foo + 1)
    } else {
      console.log('foo is NaN')
    }
  }
}
```

##### any

Самый отвратительный, мерзкий, гнусный тип. Всегда, если есть возможность, гоните его, насмехайтесь над ним!

Этот тип буквально значит "что угодно". Это когда разработчику лень разбираться, и он пишет просто `any`. Из-за этого в код попадают баги, так как этот `any` может тянуться через всю кодовую базу и ломать ее, несмотря на то, что все остальные типы у вас правильные.

Понять, что это за ублюдок, – легко – код выше про тип `unknown` не сломается ни на одном из пунктов, помеченных ошибкой, и будет выполняться, разъёбывая вам весь продакшн в рантайме в пух и прах. После такого только увольнение из компании.

Шучу конечно (но это неточно все равно), но **ЗАПОМНИТЕ: ВСЕГДА ИЗБЕГАЙТЕ ТИП `any`. ИСПОЛЬЗУЙТЕ ЕГО, ТОЛЬКО ЕСЛИ ОЧЕНЬ ХОЧЕТСЯ, НО НИКОГДА НЕ КОММИТЬТЕ В РЕПОЗИТОРИЙ. ЭТОТ УБЛЮДОК СЛОМАЕТ ВАМ ЖИЗНЬ!**

##### never

И последний тип на сегодня: `never`. Он означает, что код в этом месте никогда не может быть выполнен, unreachable code. Вот пример из реальной жизни:

```typescript
export class NeverError extends Error {
  constructor(error: never) {
    super(error);
  }
}

enum OrderStatus {
  NEW = "NEW",
  IN_PROGRESS = "IN_PROGRESS",
  COMPLETED = "COMPLETED",
}

function mapOrderStatusToText(status: OrderStatus) {
  switch(status) {
    case OrderStatus.NEW:
      return 'Новый'
    case OrderStatus.IN_PROGRESS:
      return 'В процессе'
    case OrderStatus.COMPLETED:
      return 'Завершён'
    default:
      throw new NeverError(status)
  }
}
```

Функция `mapOrderStatusToText` принимает в качестве аргумента енам статуса заказа в виде кода с бэка и маппит его в человекочитаемый текст, чтобы отрендерить на странице.

Как видно, в `switch case` мы перебрали все возможные варианты, поэтому тайпскрипт считает, что в `default case` мы попасть не можем вообще никак, и поэтому в дефолт кейсе у `status` тип `never`. И поэтому он без ошибок бьется с типом конструктора `NeverError`, который как раз ждет `never`.

Но стоит нам добавить новый статус в енам, как тайпскрипт нам сразу же скажет, что мы забыли этот кейс обработать:

```typescript
enum OrderStatus {
  NEW = "NEW",
  IN_PROGRESS = "IN_PROGRESS",
  COMPLETED = "COMPLETED",
  CANCELED = "CANCELED",
}

function mapOrderStatusToText(status: OrderStatus) {
  switch(status) {
    case OrderStatus.NEW:
      return 'Новый'
    case OrderStatus.IN_PROGRESS:
      return 'В процессе'
    case OrderStatus.COMPLETED:
      return 'Завершён'
    default: // сюда будет попадать OrderStatus.CANCELED
      throw new NeverError(status) // и мы получим ошибку TS2345: Argument of type 'OrderStatus' is not assignable to parameter of type 'never'.
  }
}
```

Иными словами: ждали `never`, то есть что это никогда не случится, а получили по факту `OrderStatus.CANCELED`, поэтому ошибка. Вообще это очень полезный способ отслеживать новые статусы и не продолбать их при разработке.

### Объединение типов

И добьем это урок объединением типов. Тут довольно всё просто.

#### Наследование

Один интерфейс можно наследовать от другого:

```typescript
interface User {
  id: string;
  firstName: string;
  lastName: string;
}

interface Admin extends User {
  ban: (userId) => void;
}
```

Тут всё как в ООП: есть просто юзер, а есть админ, который тот же юзер, но у него есть метод `ban`. То есть финальный тип для `Admin` будет такой:

```typescript
interface Admin {
  id: string;
  firstName: string;
  lastName: string;
  ban: (userId) => void;
}
```

#### ИЛИ (`|`)

Можно делать логическое ИЛИ через `|`
```typescript
let foo: number | null = null // ИЛИ number, ИЛИ null – оба типа валидны для foo
foo = 1
foo = null
let bar: number | string | boolean | null = null // можно хоть сколько типов так указывать
```

#### И (`&`)

Можно делать логическое И через `&`
```typescript
interface User {
  id: string;
  firstName: string;
  lastName: string;
}

type Admin = User & {
  ban: (userId) => void;
}
```

Внимательный читатель мог заметить, что это то же самое, что и в случае наследования. И да, это именно так, только пишется через type. Лучше всего разницу тут объяснит сам тайпскрипт [тут](https://www.typescriptlang.org/play/?#example/types-vs-interfaces).

#### Unions

И напоследок: юнионы. Юнионы это варианты значений. Например, коды ошибок с бэка удобно хранить в виде юниона строк. Самый обычный юнион выглядит так:

```typescript
type BackendErrorCodes = 'ILLEGAL_ACTION' | 'TASK_ALREAY_STARTED' | 'UNKNOWN_ERROR';
```

По сути то же самое, что и ИЛИ (`|`). Но есть один нюанс – discriminated unions. Вот пример:

```typescript
interface Success<T> { // тут снова дженерик, узнали?
  type: 'SUCCESS';
  data: T;
  error: null;
}

interface Fail {
  type: 'FAIL';
  data: null;
  error: string;
}

type Result<T> = Success<T> | Error // либо Success, либо Fail

function handleResponse<T>(response: Result<T>) {
  if (response.type === 'SUCCESS') {
    // в этом блоке кода тайпскрипт по одному полю type определил, что response будет типа Success
    // а значит у него есть data, но нет error
    // ни data, ни error проверять дополнительно не нужно
    // потому что не может быть объекта { type: "SUCCESS", data: null, error: string }
  }
  if (response.type === 'FAIL') {
    // в этом блоке кода тайпскрипт по одному полю type определил, что response будет типа Fail
    // а значит у него есть error, но нет data
    // ни data, ни error проверять дополнительно не нужно
    // потому что не может быть объекта { type: "FAIL", data: T, error: null }
  }
}
```

## Итог

Пожалуй, это самый насыщенный урок из всех. Но в то же время и самый важный. Пусть даже вы не все запомнили, зато хотя бы один раз где-то увидели, а потому знаете, где искать.

Тайпскрипт это мастхэв во фронтенде.

Я затронул далеко не все фичи тайпскрипта, только самые важные. Там много чего есть ещё, например mapped types, recursive types, conditional types, keyof keyword, infer keyword и ещё много-много всего. Именно поэтому я всегда считал тайпскрипт самой лучшей и гибкой системой типов среди всех других языков. Например, в Python нет своего тайпскрипта, они ограничиваются просто необязательными аннотациями. Представьте каково писать код с использованием библиотеки, автор которой решил забить на аннотации? Спойлер: очень грустно!

Документация тайпскрипта лежит [тут](https://www.typescriptlang.org/docs/handbook/intro.html). Если вам вдруг не хватило этого урока, то вэлком в доку!

В следующем уроке поговорим про уже про Реакт, а именно про состояние приложения.
